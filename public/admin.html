<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Story Engine – Admin</title>
  <style>
    :root{
      --bg:#0b1220; --bg2:#0f172a; --fg:#e2e8f0; --muted:#94a3b8;
      --b:#1e293b; --b2:#334155; --blue:#2563eb; --blue2:#1e3a8a;
      --green:#22c55e; --green2:#14532d; --graybtn:#475569; --red:#ef4444;
      --primary:#3b82f6; --yellow:#f59e0b;
    }
    *{box-sizing:border-box}
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; margin:0; background:var(--bg); color:var(--fg); }
    header { padding:12px 16px; background:#0f172a; color:#fff; display:flex; align-items:center; gap:12px; position:sticky; top:0; z-index:2; }
    header input { padding:8px; border-radius:8px; border:1px solid var(--b2); background:var(--bg); color:var(--fg); min-width:280px;}
    header button { padding:8px 12px; border-radius:8px; border:0; background:var(--green); color:var(--bg); cursor:pointer; }
    header .muted{color:var(--muted)}
    main { padding:16px; display:grid; gap:16px; grid-template-columns: 420px 1fr; align-items:start;}
    section { background:var(--bg); color:var(--fg); border:1px solid var(--b); border-radius:12px; padding:12px; }
    h2 { margin:0 0 8px; font-size:16px; color:#93c5fd; }
    label { display:block; margin:8px 0 4px; font-size:13px; color:#a5b4fc; }
    input, textarea, select { width:100%; padding:8px; border-radius:8px; border:1px solid var(--b2); background:var(--bg2); color:var(--fg); }
    textarea { min-height:84px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:start; }
    .row3 { display:grid; grid-template-columns: 1fr 1fr 1fr; gap:8px; }
    .row4 { display:grid; grid-template-columns: repeat(4, 1fr); gap:8px; }
    .btn { margin-top:8px; padding:8px 10px; border-radius:8px; border:0; background:var(--primary); color:var(--bg); cursor:pointer; }
    .btn.red { background:var(--red); color:#fff; }
    .btn.gray { background:var(--graybtn); color:var(--fg); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap; background:var(--bg2); padding:8px; border-radius:8px; border:1px solid var(--b2); }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid var(--b); padding:6px 8px; font-size:13px; }
    footer { padding:10px 16px; color:var(--muted); font-size:12px; }
    .hint{ color:var(--muted); font-size:12px; margin-top:4px;}
    .pill { display:inline-block; padding:2px 6px; border-radius:999px; background:#1f2937; font-size:12px; color:#cbd5e1; }
  </style>
  <!-- D3 + Dagre-D3 -->
  <script src="https://unpkg.com/d3@5.16.0/dist/d3.min.js"></script>
  <script src="https://unpkg.com/dagre-d3@0.6.4/dist/dagre-d3.min.js"></script>
</head>
<body>
<header>
  <strong>Story Engine – Admin</strong>
  <span class="muted">|</span>
  <label style="margin:0">API Key</label>
  <input id="apiKey" placeholder="x-api-key" />
  <button id="saveKey">Speichern</button>
  <span class="muted" id="baseUrlInfo"></span>
</header>

<main>
  <!-- Linke Spalte: Formulare -->
  <section>
    <h2>Sitzung</h2>
    <label>Session-ID</label>
    <div class="row">
      <input id="sessionId" placeholder="z. B. 58" />
      <button class="btn gray" id="btnNewSession">Neue Session</button>
    </div>

    <div class="row" style="margin-top:8px">
      <button class="btn" id="btnLoadSession">GET /sessions/:id</button>
      <button class="btn" id="btnHistory">GET /sessions/:id/history</button>
    </div>

    <h2 style="margin-top:12px">Start setzen</h2>
    <label>Titel</label>
    <input id="startTitle" placeholder="Start" />
    <label>Content (JSON)</label>
    <textarea id="startContent">{ "text": "Das Abenteuer beginnt hier." }</textarea>
    <button class="btn" id="btnStart">POST /sessions/:id/start</button>

    <h2 style="margin-top:12px">Option hinzufügen</h2>
    <label>Label</label>
    <input id="optLabel" placeholder="Gehe nach Norden" />
    <label>Ziel-Node</label>
    <select id="optTargetMode">
      <option value="new">Neuen Node anlegen</option>
      <option value="existing">Existierenden Node nutzen</option>
    </select>
    <div id="targetNew">
      <label>Neuer Node: Titel</label>
      <input id="optNodeTitle" placeholder="Am Flussufer" />
      <label>Neuer Node: Content (JSON)</label>
      <textarea id="optNodeContent">{ "text": "Kalter Wind ..." }</textarea>
    </div>
    <div id="targetExisting" style="display:none">
      <label>toNodeId (existiert bereits)</label>
      <input id="optToNodeId" placeholder="z. B. 203" />
    </div>

    <div class="row" style="margin-top:8px">
      <div>
        <label>Condition (JSON)</label>
        <textarea id="optCondition">{}</textarea>
      </div>
      <div>
        <label>Effect (JSON)</label>
        <textarea id="optEffect">{}</textarea>
      </div>
    </div>
    <div class="hint">Beispiel Condition:<br>
      <code>{"requires":[{"key":"inventory.key","op":"==","value":true}]}</code>
    </div>
    <button class="btn" id="btnAddOption">POST /sessions/:id/add-option (oder /expand)</button>

    <h2 style="margin-top:12px">Decision & Rewind</h2>
    <div class="row">
      <input id="edgeId" placeholder="edgeId zum Ausführen" />
      <button class="btn" id="btnDecide">POST /sessions/:id/decision</button>
    </div>
    <div class="row" style="margin-top:8px">
      <input id="rewindSteps" placeholder="Anzahl Schritte zurück (z. B. 1)" />
      <button class="btn red" id="btnRewind">POST /sessions/:id/rewind</button>
    </div>

    <h2 style="margin-top:12px">Snapshots</h2>
    <div class="row">
      <input id="snapLabel" placeholder="Label (optional, z. B. 'Vor der Tür')" />
      <button class="btn" id="btnMakeSnap">POST /sessions/:id/snapshot</button>
    </div>
    <div class="row" style="margin-top:8px">
      <button class="btn gray" id="btnListSnaps">GET /sessions/:id/snapshots</button>
      <input id="snapId" placeholder="snapId" />
      <button class="btn" id="btnRestoreSnap">POST /sessions/:id/restore/:snapId</button>
      <button class="btn red" id="btnDeleteSnap">DELETE /sessions/:id/snapshots/:snapId</button>
    </div>

    <h2 style="margin-top:12px">Edges bearbeiten/löschen</h2>
    <div class="row3">
      <div>
        <label>edgeId</label>
        <input id="editEdgeId" placeholder="z. B. 151" />
      </div>
      <div>
        <label>Neues Label</label>
        <input id="editLabel" placeholder="Neues Label..." />
      </div>
      <div>
        <label>Neues toNodeId</label>
        <input id="editToNodeId" placeholder="z. B. 204" />
      </div>
    </div>
    <label>Condition (JSON)</label>
    <textarea id="editCondition">{}</textarea>
    <label>Effect (JSON)</label>
    <textarea id="editEffect">{}</textarea>
    <div class="row">
      <button class="btn" id="btnPatchEdge">PATCH /edges/:edgeId</button>
      <button class="btn red" id="btnDeleteEdge">DELETE /edges/:edgeId</button>
    </div>

    <h2 style="margin-top:12px">Admin</h2>
    <div class="row4">
      <button class="btn gray" id="btnListNodes">GET /admin/nodes</button>
      <button class="btn" id="btnResetSeed">POST /admin/reset (mit Seed)</button>
      <button class="btn red" id="btnResetNoSeed">POST /admin/reset (ohne Seed)</button>
      <button class="btn red" id="btnClear" title="Nur wenn /admin/clear existiert">POST /admin/clear</button>
    </div>

    <h2 style="margin-top:12px">State</h2>
    <textarea id="stateEditor" class="mono" style="width:100%;min-height:120px">{}</textarea>
    <div class="row" style="margin-top:6px">
      <button class="btn" id="btnStateRefresh">State neu laden</button>
      <button class="btn" id="btnStateApply">State patchen</button>
    </div>
  </section>

  <!-- Rechte Spalte: Status + Graph -->
  <section>
    <h2>Session Status</h2>
    <div id="status" class="mono" style="margin-top:8px"></div>

    <h2 style="margin-top:16px">Nodes</h2>
    <div id="nodes" class="mono"></div>

    <h2 style="margin-top:16px">Snapshots</h2>
    <div id="snaps" class="mono"></div>

    <h2 style="margin-top:16px">Graph (Session)</h2>
    <div class="row">
      <button class="btn gray" id="btnGraphVisited">Graph: visited</button>
      <button class="btn gray" id="btnGraphAll">Graph: all</button>
    </div>
    <svg id="graphSvg" width="100%" height="480" style="background:var(--bg);border:1px solid var(--b);border-radius:12px;margin-top:8px"></svg>
  </section>
</main>

<footer>Admin-UI · spricht mit deiner API unter <span id="baseUrlFoot"></span></footer>

<script>
  // === Konfiguration & Helpers ===
  const BASE_URL = "https://live-story-teller-gu7wv.ondigitalocean.app";
  const els = {
    apiKey: document.getElementById("apiKey"),
    saveKey: document.getElementById("saveKey"),
    baseUrlInfo: document.getElementById("baseUrlInfo"),
    baseUrlFoot: document.getElementById("baseUrlFoot"),
    sessionId: document.getElementById("sessionId"),
    btnNewSession: document.getElementById("btnNewSession"),
    btnLoadSession: document.getElementById("btnLoadSession"),
    btnHistory: document.getElementById("btnHistory"),
    status: document.getElementById("status"),
    nodes: document.getElementById("nodes"),
    // Start
    startTitle: document.getElementById("startTitle"),
    startContent: document.getElementById("startContent"),
    btnStart: document.getElementById("btnStart"),
    // Add option
    optLabel: document.getElementById("optLabel"),
    optTargetMode: document.getElementById("optTargetMode"),
    targetNew: document.getElementById("targetNew"),
    targetExisting: document.getElementById("targetExisting"),
    optNodeTitle: document.getElementById("optNodeTitle"),
    optNodeContent: document.getElementById("optNodeContent"),
    optToNodeId: document.getElementById("optToNodeId"),
    optCondition: document.getElementById("optCondition"),
    optEffect: document.getElementById("optEffect"),
    btnAddOption: document.getElementById("btnAddOption"),
    // Decide/rewind
    edgeId: document.getElementById("edgeId"),
    btnDecide: document.getElementById("btnDecide"),
    rewindSteps: document.getElementById("rewindSteps"),
    btnRewind: document.getElementById("btnRewind"),
    // Snapshots
    snapLabel: document.getElementById("snapLabel"),
    btnMakeSnap: document.getElementById("btnMakeSnap"),
    btnListSnaps: document.getElementById("btnListSnaps"),
    snapId: document.getElementById("snapId"),
    btnRestoreSnap: document.getElementById("btnRestoreSnap"),
    btnDeleteSnap: document.getElementById("btnDeleteSnap"),
    snaps: document.getElementById("snaps"),
    // Edge edit
    editEdgeId: document.getElementById("editEdgeId"),
    editLabel: document.getElementById("editLabel"),
    editToNodeId: document.getElementById("editToNodeId"),
    editCondition: document.getElementById("editCondition"),
    editEffect: document.getElementById("editEffect"),
    btnPatchEdge: document.getElementById("btnPatchEdge"),
    btnDeleteEdge: document.getElementById("btnDeleteEdge"),
    // Admin
    btnListNodes: document.getElementById("btnListNodes"),
    btnResetSeed: document.getElementById("btnResetSeed"),
    btnResetNoSeed: document.getElementById("btnResetNoSeed"),
    btnClear: document.getElementById("btnClear"),
    // State
    stateEditor: document.getElementById("stateEditor"),
    btnStateRefresh: document.getElementById("btnStateRefresh"),
    btnStateApply: document.getElementById("btnStateApply"),
    // Graph
    btnGraphVisited: document.getElementById("btnGraphVisited"),
    btnGraphAll: document.getElementById("btnGraphAll"),
    graphSvg: document.getElementById("graphSvg")
  };

  // Nur EIN Set/Mode global
  let currentVoteOptions = new Set();
  window.currentGraphMode = "visited";

  // Persistenter Key
  els.apiKey.value = localStorage.getItem("xApiKey") || "dev-secret-change-me";
  els.saveKey.onclick = () => {
    localStorage.setItem("xApiKey", els.apiKey.value || "");
    alert("API-Key gespeichert.");
  };
  els.baseUrlInfo.textContent = BASE_URL;
  els.baseUrlFoot.textContent = BASE_URL;

  els.optTargetMode.onchange = () => {
    const mode = els.optTargetMode.value;
    els.targetNew.style.display = mode === "new" ? "block" : "none";
    els.targetExisting.style.display = mode === "existing" ? "block" : "none";
  };

  function headers() {
    const h = { "Content-Type": "application/json" };
    const key = els.apiKey.value.trim();
    if (key) h["x-api-key"] = key;
    return h;
  }
  async function api(path, init) {
    const res = await fetch(BASE_URL + path, init);
    const txt = await res.text();
    let data = null;
    try { data = txt ? JSON.parse(txt) : null; } catch { data = txt; }
    if (!res.ok) throw data || { error: "http_error", status: res.status };
    return data;
  }
  function showStatus(obj) { els.status.textContent = JSON.stringify(obj, null, 2); }
  function showNodes(obj)  { els.nodes.textContent  = JSON.stringify(obj, null, 2); }
  function showSnaps(obj)  { els.snaps.textContent  = JSON.stringify(obj, null, 2); }

  // Utils
  function safeJSON(text, fallback) {
    try { return JSON.parse(text); } catch { return fallback; }
  }
  function getByPath(obj, path) {
    if (!obj || !path) return undefined;
    const parts = String(path).split(".");
    let cur = obj;
    for (const p of parts) {
      if (cur == null || typeof cur !== "object") return undefined;
      cur = cur[p];
    }
    return cur;
  }
  function evalCondition(cond, state) {
    if (!cond || !Array.isArray(cond.requires) || cond.requires.length === 0) {
      return { met: true, unmet: [] };
    }
    const unmet = [];
    for (const r of cond.requires) {
      const key = r?.key, op = r?.op || "==", val = r?.value;
      const actual = getByPath(state, key);
      let ok = false;
      switch (op) {
        case "==": ok = (actual === val); break;
        case "!=": ok = (actual !== val); break;
        case ">":  ok = (typeof actual === "number" && actual >  val); break;
        case ">=": ok = (typeof actual === "number" && actual >= val); break;
        case "<":  ok = (typeof actual === "number" && actual <  val); break;
        case "<=": ok = (typeof actual === "number" && actual <= val); break;
        case "exists":     ok = (actual !== undefined && actual !== null); break;
        case "not_exists": ok = (actual === undefined || actual === null); break;
        default: ok = false;
      }
      if (!ok) {
        const need = (op === "exists" || op === "not_exists")
          ? `${key} ${op}`
          : `${key} ${op} ${JSON.stringify(val)}`;
        unmet.push(need);
      }
    }
    return { met: unmet.length === 0, unmet };
  }

  // Session
  els.btnNewSession.onclick = async () => {
    try {
      const r = await api("/sessions", { method:"POST", headers: headers(), body: JSON.stringify({ startNodeId: null }) });
      els.sessionId.value = r.id;
      await loadSession();
    } catch (e) { showStatus(e); }
  };
  els.btnLoadSession.onclick = loadSession;
  async function loadSession() {
    const sid = Number(els.sessionId.value);
    if (!Number.isFinite(sid)) return alert("Session-ID fehlt/ungültig.");
    try {
      const r = await api(`/sessions/${sid}`, { headers: headers() });
      showStatus(r);
      els.stateEditor.value = JSON.stringify(r.state || {}, null, 2);
    } catch (e) { showStatus(e); }
  }
  els.btnHistory.onclick = async () => {
    const sid = Number(els.sessionId.value);
    if (!Number.isFinite(sid)) return alert("Session-ID fehlt/ungültig.");
    try {
      const r = await api(`/sessions/${sid}/history`, { headers: headers() });
      showStatus(r);
    } catch (e) { showStatus(e); }
  };

  // Start setzen
  els.btnStart.onclick = async () => {
    try {
      const sid = Number(els.sessionId.value);
      const body = {
        nodeTitle: els.startTitle.value || "Start",
        nodeContent: safeJSON(els.startContent.value, { text: "Start..." })
      };
      await api(`/sessions/${sid}/start`, { method:"POST", headers: headers(), body: JSON.stringify(body) });
      await loadSession();
    } catch (e) { showStatus(e); }
  };

  // Option hinzufügen (new/existing, mit Condition/Effect)
  els.optTargetMode.onchange();
  els.btnAddOption.onclick = async () => {
    try {
      const sid = Number(els.sessionId.value);
      const mode = els.optTargetMode.value;
      const label = (els.optLabel.value || "").trim();
      if (!label) return alert("Label fehlt.");

      const cond = safeJSON(els.optCondition.value || "{}", null);
      const eff  = safeJSON(els.optEffect.value || "{}", null);
      let body;

      if (mode === "new") {
        body = {
          label,
          nodeTitle: els.optNodeTitle.value || "Neuer Knoten",
          nodeContent: safeJSON(els.optNodeContent.value, { text: "" }),
          condition: (cond && Object.keys(cond).length ? cond : null),
          effect:    (eff  && Object.keys(eff).length  ? eff  : null)
        };
        await api(`/sessions/${sid}/add-option`, { method:"POST", headers: headers(), body: JSON.stringify(body) });
      } else {
        const toNodeId = Number(els.optToNodeId.value);
        if (!Number.isFinite(toNodeId)) return alert("toNodeId ist ungültig.");
        body = {
          edges: [{
            label, toNodeId,
            condition: (cond && Object.keys(cond).length ? cond : null),
            effect:    (eff  && Object.keys(eff).length  ? eff  : null)
          }]
        };
        await api(`/sessions/${sid}/expand`, { method:"POST", headers: headers(), body: JSON.stringify(body) });
      }
      await loadSession();
    } catch (e) { showStatus(e); }
  };

  // Decision & Rewind
  els.btnDecide.onclick = async () => {
    try {
      const sid = Number(els.sessionId.value);
      const edgeId = Number(els.edgeId.value);
      if (!Number.isFinite(edgeId)) return alert("edgeId fehlt/ungültig.");
      await api(`/sessions/${sid}/decision`, { method:"POST", headers: headers(), body: JSON.stringify({ edgeId }) });
      await loadSession();
      await loadGraph(window.currentGraphMode);
    } catch (e) { showStatus(e); }
  };
  els.btnRewind.onclick = async () => {
    try {
      const sid = Number(els.sessionId.value);
      const steps = Number(els.rewindSteps.value || "1");
      await api(`/sessions/${sid}/rewind`, { method:"POST", headers: headers(), body: JSON.stringify({ steps }) });
      await loadSession();
      await loadGraph(window.currentGraphMode);
    } catch (e) { showStatus(e); }
  };

  // Snapshots
  els.btnMakeSnap.onclick = async () => {
    const sid = Number(els.sessionId.value);
    if (!Number.isFinite(sid)) return alert("Session-ID fehlt/ungültig.");
    const label = (els.snapLabel.value || "").trim();
    const body = label ? { label } : {};
    try {
      await api(`/sessions/${sid}/snapshot`, { method: "POST", headers: headers(), body: JSON.stringify(body) });
      await listSnaps();
    } catch (e) { showStatus(e); }
  };
  async function listSnaps() {
    const sid = Number(els.sessionId.value);
    if (!Number.isFinite(sid)) return alert("Session-ID fehlt/ungültig.");
    try {
      const r = await api(`/sessions/${sid}/snapshots`, { headers: headers() });
      showSnaps(r);
      if (Array.isArray(r.snapshots) && r.snapshots.length) {
        els.snapId.value = r.snapshots[0].id;
      }
    } catch (e) { showSnaps(e); }
  }
  els.btnListSnaps.onclick = listSnaps;
  els.btnRestoreSnap.onclick = async () => {
    const sid = Number(els.sessionId.value);
    const snapId = Number(els.snapId.value);
    if (!Number.isFinite(sid) || !Number.isFinite(snapId)) return alert("IDs prüfen.");
    try {
      await api(`/sessions/${sid}/restore/${snapId}`, { method:"POST", headers: headers(), body: JSON.stringify({ clearHistory: false }) });
      await loadSession();
      await listSnaps();
    } catch (e) { showStatus(e); }
  };
  els.btnDeleteSnap.onclick = async () => {
    const sid = Number(els.sessionId.value);
    const snapId = Number(els.snapId.value);
    if (!Number.isFinite(sid) || !Number.isFinite(snapId)) return alert("IDs prüfen.");
    try {
      await api(`/sessions/${sid}/snapshots/${snapId}`, { method:"DELETE", headers: headers() });
      await listSnaps();
    } catch (e) { showSnaps(e); }
  };

  // Edge Patch/Delete
  els.btnPatchEdge.onclick = async () => {
    try {
      const edgeId = Number(els.editEdgeId.value);
      if (!Number.isFinite(edgeId)) return alert("edgeId fehlt/ungültig.");

      const body = {};
      if (els.editLabel.value.trim()) body.label = els.editLabel.value.trim();
      if (els.editToNodeId.value.trim()) {
        const n = Number(els.editToNodeId.value.trim());
        if (!Number.isFinite(n)) return alert("toNodeId ungültig.");
        body.toNodeId = n;
      }
      const condTxt = els.editCondition.value.trim();
      if (condTxt) body.condition = safeJSON(condTxt, {});
      const effTxt = els.editEffect.value.trim();
      if (effTxt) body.effect = safeJSON(effTxt, {});
      await api(`/edges/${edgeId}`, { method:"PATCH", headers: headers(), body: JSON.stringify(body) });
      await loadSession();
      await loadGraph(window.currentGraphMode);
    } catch (e) { showStatus(e); }
  };
  els.btnDeleteEdge.onclick = async () => {
    try {
      const edgeId = Number(els.editEdgeId.value);
      if (!Number.isFinite(edgeId)) return alert("edgeId fehlt/ungültig.");
      await api(`/edges/${edgeId}`, { method:"DELETE", headers: headers() });
      await loadSession();
      await loadGraph(window.currentGraphMode);
    } catch (e) { showStatus(e); }
  };

  // Admin
  els.btnListNodes.onclick = async () => {
    try { const r = await api(`/admin/nodes`, { headers: headers() }); showNodes(r); }
    catch (e) { showNodes(e); }
  };
  els.btnResetSeed.onclick = async () => {
    try {
      const r = await api(`/admin/reset`, { method: "POST", headers: headers(), body: JSON.stringify({ seed: true }) });
      showNodes(r); els.sessionId.value = ""; els.status.textContent = "Reset (mit Seed) done."; els.stateEditor.value = "{}";
    } catch (e) { showNodes(e); }
  };
  els.btnResetNoSeed.onclick = async () => {
    try {
      const r = await api(`/admin/reset`, { method: "POST", headers: headers(), body: JSON.stringify({ seed: false }) });
      showNodes(r); els.sessionId.value = ""; els.status.textContent = "Reset (ohne Seed) done."; els.stateEditor.value = "{}";
    } catch (e) { showNodes(e); }
  };
  els.btnClear.onclick = async () => {
    try {
      const r = await api(`/admin/clear`, { method: "POST", headers: headers() });
      showNodes(r); els.sessionId.value = ""; els.status.textContent = "Clear done."; els.stateEditor.value = "{}";
    } catch (e) { showNodes(e); }
  };

  // State
  els.btnStateRefresh.onclick = async () => {
    const sid = Number(els.sessionId.value);
    if (!Number.isFinite(sid)) return alert("Session-ID fehlt/ungültig.");
    try {
      const r = await api(`/sessions/${sid}`, { headers: headers() });
      els.stateEditor.value = JSON.stringify(r.state || {}, null, 2);
      showStatus(r);
    } catch (e) { showStatus(e); }
  };
  els.btnStateApply.onclick = async () => {
    const sid = Number(els.sessionId.value);
    if (!Number.isFinite(sid)) return alert("Session-ID fehlt/ungültig.");
    let body = {};
    try { body = JSON.parse(els.stateEditor.value || "{}"); } catch { return alert("Ungültiges JSON."); }
    try {
      const r = await api(`/sessions/${sid}/state`, { method: "PATCH", headers: headers(), body: JSON.stringify(body) });
      els.stateEditor.value = JSON.stringify(r.state || {}, null, 2);
      await loadSession();
      await loadGraph(window.currentGraphMode);
    } catch (e) { showStatus(e); }
  };

  // Graph-Steuerung
  els.btnGraphVisited.onclick = () => loadGraph("visited");
  els.btnGraphAll.onclick     = () => loadGraph("all");

  function sessionColor(sid) {
    if (!Number.isFinite(sid)) return "#22c55e";
    const hue = (sid * 57) % 360;
    return `hsl(${hue} 75% 45%)`;
  }

  function renderGraph(payload, sessionMarkers = []) {
    try {
      const { nodes = [], edges = [], currentNodeId = null, visitedNodeIds = [] } = payload || {};
      const visitedSet = new Set(Array.isArray(visitedNodeIds) ? visitedNodeIds : []);
      const state = safeJSON(els.stateEditor?.value || "{}", {});

      const g = new dagreD3.graphlib.Graph().setGraph({ rankdir: "LR", nodesep: 30, ranksep: 60 });

      // Nodes
      nodes.forEach(n => {
        let fill = "#0f172a", stroke = "#334155";
        const sid = Number(els.sessionId.value);
        const sessCol = sessionColor(sid);
        if (n.id === currentNodeId) { fill = sessCol; stroke = sessCol; }
        else if (visitedSet.has(n.id)) { fill = "#2563eb"; stroke = "#1e3a8a"; }

        const label = `${n.id}\n${n.title || ""}`;
        g.setNode(String(n.id), {
          label,
          rx: 8, ry: 8,
          style: `fill:${fill};stroke:${stroke};stroke-width:2px;color:#0b1220`,
          labelStyle: "fill:#e2e8f0"
        });
      });

      // Edges
      const voteSet = (currentVoteOptions && typeof currentVoteOptions.has === "function") ? currentVoteOptions : new Set();

      edges.forEach(e => {
        try {
          const inVote = voteSet.has(Number(e.id));
          let edgeText = `[${e.id}] ${e.label || ""}`;
          let style = inVote ? "stroke:#f59e0b;stroke-width:2.2px;fill:none" : "stroke:#475569;fill:none";
          let arrowStyle = inVote ? "fill:#f59e0b" : "fill:#475569";
          let labelStyle = "fill:#cbd5e1;font-size:12px";

          if (window.currentGraphMode === "all") {
            const cond = (e && (e.condition_json || e.condition)) || null;
            const res = evalCondition(cond, state);
            if (!res.met) {
              edgeText += `\n(needs ${res.unmet.join(", ") || "condition"})`;
              labelStyle = "fill:#ef4444;font-size:12px"; // nur Label rot
            }
          }

          g.setEdge(String(e.from_node_id), String(e.to_node_id), {
            label: edgeText,
            lineInterpolate: "basis",
            style,
            arrowheadStyle: arrowStyle,
            labelStyle
          });
        } catch (edgeErr) {
          console.warn("Edge skipped:", edgeErr, e);
        }
      });

      // Rendern
      const svg = d3.select(els.graphSvg);
      svg.selectAll("*").remove();
      const inner = svg.append("g");
      const render = new dagreD3.render();
      render(inner, g);

      // Session-Marker (optional)
      try {
        const groupByNode = new Map();
        (sessionMarkers || []).forEach(m => {
          if (!m || m.nodeId == null) return;
          const arr = groupByNode.get(m.nodeId) || [];
          arr.push(m);
          groupByNode.set(m.nodeId, arr);
        });
        groupByNode.forEach((arr, nodeId) => {
          const nodeG = d3.select(els.graphSvg).selectAll("g.node")
            .filter(function() {
              const t = d3.select(this).select("tspan").text() || "";
              return t.startsWith(String(nodeId));
            });
          if (nodeG.empty()) return;

          const markersG = nodeG.append("g").attr("class", "session-markers");
          const rect = nodeG.select("rect");
          const w = Number(rect.attr("width") || 80);
          const h = Number(rect.attr("height") || 30);
          const offset = 8;

          arr.forEach((m, idx) => {
            const cx = (w/2) - 8 - (idx * offset);
            const cy = -(h/2) + 8;
            const isFocused = Number(els.sessionId.value) === Number(m.sid);
            const r = isFocused ? 7.5 : 6;
            markersG.append("circle")
              .attr("cx", cx).attr("cy", cy).attr("r", r)
              .attr("fill", m.color || "#22c55e")
              .attr("stroke", "#0b1220").attr("stroke-width", 2)
              .append("title").text(`Session #${m.sid}`);
          });
        });
      } catch (markerErr) {
        console.warn("Markers skipped:", markerErr);
      }

      // Auto-Zoom/Center
      const graphDims = g.graph();
      const width  = graphDims.width  || 1;
      const height = graphDims.height || 1;
      const svgWidth  = els.graphSvg.clientWidth  || 800;
      const svgHeight = els.graphSvg.clientHeight || 480;
      const scale = Math.min((svgWidth - 40) / width, (svgHeight - 40) / height, 1.2);
      const x = (svgWidth - (width * scale)) / 2;
      const y = (svgHeight - (height * scale)) / 2;
      d3.select(els.graphSvg).select("g")
        .attr("transform", `translate(${x},${y}) scale(${scale})`);
    } catch (err) {
      console.error("renderGraph failed:", err, payload);
    }
  }

  // Graph Buttons
  els.btnGraphVisited.onclick = () => loadGraph("visited");
  els.btnGraphAll.onclick     = () => loadGraph("all");
</script>
</body>
</html>
